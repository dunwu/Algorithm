# 数组和链表

> 数组和链表分别代表了连续空间和不连续空间的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二
> 叉树、B+ 树等，实际上都是这两者的结合和变化。

<!-- TOC depthFrom:2 depthTo:3 -->

- [1. 数组和链表的特性](#1-数组和链表的特性)
  - [1.1. 数组的特性](#11-数组的特性)
  - [1.2. 链表的特性](#12-链表的特性)
- [2. 数组和链表的基本操作](#2-数组和链表的基本操作)
  - [2.1. 一维数组的基本操作](#21-一维数组的基本操作)
  - [2.2. 二维数组的基本操作](#22-二维数组的基本操作)
  - [2.3. 单链表的基本操作](#23-单链表的基本操作)
  - [2.4. 双链表的基本操作](#24-双链表的基本操作)
- [3. 参考资料](#3-参考资料)

<!-- /TOC -->

## 1. 数组和链表的特性

数组和链表的对比：

- 存储方式：
  - 数组用 **连续** 的内存空间来存储数据。
  - 链表用 **不连续** 的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。
- 特性差异：
  - 数组的 **查找** 效率高于链表。
  - 链表的 **添加**、**删除** 效率高于数组。

### 1.1. 数组的特性

数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先分配好空间大小。这使得数组有以下特性：

1. **用连续的内存空间来存储数据**。
2. **数组支持随机访问，根据下标随机访问的时间复杂度为 `O(1)`**。
3. **空间大小固定**，一旦建立，不能再改变。
4. 在旧式编程语言中（如有中阶语言之称的 C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险。

#### 一维数组

数组可以有一个或多个维度。

一维数组是一种线性数组，其中元素的访问是以行或列索引的单一下标表示。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220309194620.png)

在上面的例子中，数组 a 中有 5 个元素。也就是说，a 的长度是 6 。我们可以使用 a[0] 来表示数组中的第一个元素。因此，a[0] = 1 。类似地，a[1] = 2，a[2] = 3，依此类推。

#### 多维数组

类似于一维数组，二维数组也是由元素的序列组成。但是这些元素可以排列在矩形网格中而不是直线上。

在一些语言中，多维数组实际上是在内部作为一维数组实现的，而在其他一些语言中，实际上根本没有多维数组。

（1）C++ 将二维数组存储为一维数组。

下图显示了*大小为 M \* N 的数组 A* 的实际结构：

![img](https://raw.githubusercontent.com/dunwu/images/dev/cs/data-structure/array/C++二维数组.png)

因此，如果我们将 A 定义为也包含 _M \* N_ 个元素的一维数组，那么实际上 A[i][j] 就等于 A[i * N + j]。

（2）在 Java 中，二维数组实际上是包含着 M 个元素的一维数组，每个元素都是包含有 N 个整数的数组。

下图显示了 Java 中二维数组 A 的实际结构：

![img](https://raw.githubusercontent.com/dunwu/images/dev/cs/data-structure/array/JAVA二维数组.png)

普通数组采用一个整数来作下标。多维数组（高维数组）的概念特别是在数值计算和图形应用方面非常有用。我们在多维数组之中采用一系列有序的整数来标注，如在[ 3,1,5 ] 。这种整数列表之中整数的个数始终相同，且被称为数组的“维度”。关于每个数组维度的边界称为“维”。维度为 k 的数组通常被称为 k 维。

多维数组的数组名字，在表达式中自动转换为数组首元素地址值，但这个首元素实际上是去除数组下标第一维之后的数组剩余部分。

### 1.2. 链表的特性

> **链表用不连续的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链**。

链表具有以下特性：

- 链表允许插入和移除任意位置上的节点，其时间复杂度为 `O(1)`
- 链表没有数组的随机访问特性，**链表只支持顺序访问**，其时间复杂度为 `O(n)`。
- 数组的空间大小是固定的，而**链表的空间大小可以动态增长**。相比于数组，链表支持扩容，显然更为灵活，但是由于多了指针域，空间开销也更大。
- 链表相比于数组，多了头指针、尾指针（非必要），合理使用可以大大提高访问效率。

链表有多种类型：

- 单链表
- 双链表
- 循环链表

#### 单链表

单链表中的每个结点不仅包含数据值，还包含一个指针，指向其后继节点。通过这种方式，单链表将所有结点按顺序组织起来。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220309193834.png)

与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按 `索引` 来 `访问元素` 平均要花费 `O(N)` 时间，其中 N 是链表的长度。

#### 双链表

双链表中的每个结点不仅包含数据值，还包含两个指针，分别指向指向其前驱节点和后继节点。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220309194914.png)

双链表以类似的方式工作，但`还有一个引用字段`，称为`“prev”`字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。

## 2. 数组和链表的基本操作

关于数组和链表的基本操作，网上和各种书籍、教程中已经有大量的示例，感兴趣可以自行搜索。本文只是简单展示一下数组和链表的基本操作。

### 2.1. 一维数组的基本操作

```java
public class Main {
    public static void main(String[] args) {
        // 1. Initialize
        int[] a0 = new int[5];
        int[] a1 = {1, 2, 3};
        // 2. Get Length
        System.out.println("The size of a1 is: " + a1.length);
        // 3. Access Element
        System.out.println("The first element is: " + a1[0]);
        // 4. Iterate all Elements
        System.out.print("[Version 1] The contents of a1 are:");
        for (int i = 0; i < a1.length; ++i) {
            System.out.print(" " + a1[i]);
        }
        System.out.println();
        System.out.print("[Version 2] The contents of a1 are:");
        for (int item: a1) {
            System.out.print(" " + item);
        }
        System.out.println();
        // 5. Modify Element
        a1[0] = 4;
        // 6. Sort
        Arrays.sort(a1);
    }
}
```

### 2.2. 二维数组的基本操作

```java
public class TwoDimensionArray {
    private static void printArray(int[][] a) {
        for (int i = 0; i < a.length; ++i) {
            System.out.println(a[i]);
        }
        for (int i = 0; i < a.length; ++i) {
            for (int j = 0; a[i] != null && j < a[i].length; ++j) {
                System.out.print(a[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        System.out.println("Example I:");
        int[][] a = new int[2][5];
        printArray(a);
        System.out.println("Example II:");
        int[][] b = new int[2][];
        printArray(b);
        System.out.println("Example III:");
        b[0] = new int[3];
        b[1] = new int[5];
        printArray(b);
    }
}
```

### 2.3. 单链表的基本操作

单链表节点的数据结构

```java
public class ListNode<E> {
    E value;
    ListNode<E> next; // 指向后继节点
}

public class SingleLinkList<E> {
    private ListNode<E> head; // 头节点
}
```

（1）从头部添加节点（即头插法）

```java
void addHead(E value) {
    ListNode<E> newNode = new ListNode<>(value, null);
    newNode.next = this.head.next;
    this.head.next = newNode;
}
```

（2）从尾部添加节点（即尾插法）

```java
void addTail(E value) {
    // init new node
    ListNode<E> newNode = new ListNode<>(value, null);

    // find the last node
    ListNode<E> node = this.head;
    while (node.next != null) {
        node = node.next;
    }

    // add new node to tail
    node.next = newNode;
}
```

（3）删除节点

找到要删除元素的前驱节点，将前驱节点的 next 指针指向下一个节点。

```java
public void remove(E value) {
    ListNode<E> prev = this.head;
    while (prev.next != null) {
        ListNode<E> curr = prev.next;
        if (curr.value.equals(value)) {
            prev.next = curr.next;
            break;
        }
        prev = prev.next;
    }
}
```

（4）查找节点

从头开始查找，一旦发现有数值与查找值相等的节点，直接返回此节点。如果遍历结束，表明未找到节点，返回 null。

```java
public ListNode<E> find(E value) {
    ListNode<E> node = this.head.next;
    while (node != null) {
        if (node.value.equals(value)) {
            return node;
        }
        node = node.next;
    }
    return null;
}
```

### 2.4. 双链表的基本操作

双链表节点的数据结构：

```java
static class DListNode<E> {
    E value;
    DListNode<E> prev; // 指向前驱节点
    DListNode<E> next; // 指向后继节点
}

public class DoubleLinkList<E> {
    /** 头节点 */
    private DListNode<E> head;
    /** 尾节点 */
    private DListNode<E> tail;
}
```

（1）从头部添加节点

```java
public void addHead(E value) {
    DListNode<E> newNode = new DListNode<>(null, value, null);

    this.head.next.prev = newNode;
    newNode.next = this.head.next;

    this.head.next = newNode;
    newNode.prev = this.head;
}
```

（2）从尾部添加节点

```java
public void addTail(E value) {
    DListNode<E> newNode = new DListNode<>(null, value, null);

    this.tail.prev.next = newNode;
    newNode.prev = this.tail.prev;

    this.tail.prev = newNode;
    newNode.next = this.tail;
}
```

（3）删除节点

```java
public void remove(E value) {
    DListNode<E> prev = this.head;
    while (prev.next != this.tail) {
        DListNode<E> curr = prev.next;
        if (curr.value.equals(value)) {
            prev.next = curr.next;
            curr.next.prev = prev;
            curr.next = null;
            curr.prev = null;
            break;
        }
        prev = prev.next;
    }
}
```

（4）查找节点

```java
public DListNode<E> find(E value) {
    DListNode<E> node = this.head.next;
    while (node != this.tail) {
        if (node.value.equals(value)) {
            return node;
        }
        node = node.next;
    }
    return null;
}
```

## 数组和链表的比较

- **存储方式**
  - 数组用 **连续** 的内存空间来存储数据。
  - 链表用 **不连续** 的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。
- **访问方式**
  - 数组**支持随机访问**。根据下标随机访问的时间复杂度为 `O(1)`
  - 链表**不支持随机访问**，只能顺序访问。
- **空间大小**
  - 数组空间**大小固定**，扩容只能采用复制数组的方式。
  - 链表空间**大小不固定**，扩容灵活。
- **效率比较**
  - 数组的 **查找** 效率高于链表。
  - 链表的 **添加**、**删除** 效率高于数组。

## 3. 参考资料

- https://zh.wikipedia.org/wiki/数组
- [数据结构（C 语言版）](https://item.jd.com/12407475.html) - [严蔚敏](https://book.jd.com/writer/严蔚敏_1.html)，[吴伟民](https://book.jd.com/writer/吴伟民_1.html)
- [数据结构：链表](https://www.jianshu.com/p/73d56c3d228c)
- [leetcode 链表题库](https://leetcode-cn.com/tag/linked-list/)
