# 跳表

<!-- TOC depthFrom:2 depthTo:3 -->

- [1. 什么是跳表](#1-什么是跳表)
  - [1.1. 高效的动态插入和删除](#11-高效的动态插入和删除)
  - [1.2. 跳表索引动态更新](#12-跳表索引动态更新)
- [2. 为什么需要跳表](#2-为什么需要跳表)
- [3. 跳表的应用场景](#3-跳表的应用场景)
- [4. 参考资料](#4-参考资料)

<!-- /TOC -->

## 1. 什么是跳表

只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫作**跳表**（Skip list）。

跳表是一种各方面性能都比较优秀的**动态数据结构**，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代[红黑树](https://zh.wikipedia.org/wiki/红黑树)（Red-black tree）。

由于链表只支持顺序查找，所以其查找效率较低，时间复杂度是 `O(n)`。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220310101420.jpg)

跳表查询有多快？

在一个具有多级索引的跳表中，第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 `k-1` 级索引的结点个数的 `1/2`，那第 k 级索引结点的个数就是 `n/(2k)`。

所以在跳表中查询任意数据的时间复杂度就是 `O(logn)`。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220310102943.jpg)

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220310103133.jpg)

**这种链表加多级索引的结构，就是跳表**。

### 1.1. 高效的动态插入和删除

跳表不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 `O(logn)`。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220310104105.jpg)

- **插入操作**：对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。
- **删除操作**：如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。

### 1.2. 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220310104519.jpg)

如红黑树、AVL 树这样的平衡二叉树，是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护前面提到的“平衡性”。

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？可以通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220310104646.jpg)

## 2. 为什么需要跳表

跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 `O(logn)`。

跳表的空间复杂度是 `O(n)`。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。

## 3. 跳表的应用场景

经典实现：Redis 的 Sorted Set、JDK 的 `ConcurrentSkipListMap` 和 `ConcurrentSkipListSet` 都是基于跳表实现。

为什么 Redis 要用跳表来实现有序集合，而不是红黑树？

Redis 中的有序集合支持的核心操作主要有下面这几个：

- 插入一个数据；
- 删除一个数据；
- 查找一个数据；
- 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；
- 迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。

## 4. 参考资料

- [数据结构与算法之美](https://time.geekbang.org/column/intro/100017301)
